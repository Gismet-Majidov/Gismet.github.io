[
  
  {
    "title": "LeetCode 2611. Mice and Cheese",
    "url": "/posts/LeetCode-Mice-and-Cheese2611/",
    "categories": "Problem-Solving, LeetCode",
    "tags": "LeetCode, Greedy, Sorting",
    "date": "2024-04-09 08:50:00 +0400",
    





    
    "snippet": "2611. Mice and CheeseThere are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.A point of the cheese with index i (0-indexed) is:  reward1[i] if t...",
    "content": "2611. Mice and CheeseThere are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.A point of the cheese with index i (0-indexed) is:  reward1[i] if the first mouse eats it.  reward2[i] if the second mouse eats it.You are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.Return the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.Example 1:Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2 Output: 15Explanation: In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.The total points are 4 + 4 + 3 + 4 = 15.It can be proven that 15 is the maximum total points that the mice can achieve.Example 2:Input: reward1 = [1,1], reward2 = [1,1], k = 2Output: 2Explanation: In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.The total points are 1 + 1 = 2.It can be proven that 2 is the maximum total points that the mice can achieve.First ideaWe are asked to maximize points mice can achieve by eating all the cheese.But there is a catch! The first mouse must eat exactly k types of cheese. The second mouse can eat any amount of cheese. Thus second mouse will eat the rest of the cheese after the first mouse eats k types of cheese.Which types of cheese should the first mouse eat?Since we want to maximize the points, let’s allow the first mouse to eat k types of cheese with the most points. Let’s have a look at the first example again.reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2For this example, the first mouse eats two types of cheese with points 3 and 4 (in reward1), achieving a total of 7 points. Now that the first mouse ate exactly k types of cheese, the second mouse can eat up the rest of the cheese, getting a totle of 8 points by eating the first and the second type of cheese. In total, the mice obtain 15 points, which is the maximum that can be achieved.Is this appraoch correct? Does it always yield the maximim points?Basically, the first mouse ate the k types of cheese with the most points.Let’s see another example.reward1 = [1, 1, 3, 4], reward2 = [4, 4, 50, 50] k = 2Now let’s try our approach on this example. We let the first mouse eat 2 types of cheese with the most points. The first mouse gets 3 + 4 = 7 points by eating the third and fourth types of cheese (in reward1). The second mouse eats the first and the second types of cheese, getting a total of 8 points. Overall, we got 15 again whereas the maximium is 102 by letting the first mouse eat the first and the second types of cheese and the second mouse eat the third and fourth types of cheese. So our idea of allowing the first mouse to greedily eat the types of cheese with the most points falls short.Second attemptLet’s change our previous approach a little bit.We will let the first mouse eat k types of cheese with the most points only if the corresponding points of the second mouse is less than the points of the first mouse. Let’s examine the previous example for which our first idea failed.reward1 = [1, 1, 3, 4], reward2 = [4, 4, 50, 50] k = 2The fourth cheese is the most valuable cheese for the first mouse but it gives less points if the first mouse eats it. Therefore we let the second mouse eat it as it gives us more points. The next valuable cheese for the first mouse is the third cheese, which gives 3 points. Again it is less than the point the second mouse achieves. Once again we let the second mouse eat it. Now we are only left with 2 types of cheese and the first mouse have not yet eaten any cheese. We can’t let the second mouse eat any more cheese because then we would not have enough cheese for the first mouse. So the last 2 types of cheese got eaten by the first mouse. We get a total of 102 points, which is actually the maximim value.Is this approach correct for all inputs?Well, let’s see another example.reward1 = [1, 1, 2, 3], reward2 = [60, 60, 50, 50] k = 2We allow the second mouse to eat the third and fourth cheese because they would give us less points if the first mouse ate them. So the second mouse ate them. Now the first mouse is forced to eat the first and second types of cheese. This way, we get 102 points while the optimal answer is 125. The first mouse should eat the third and fourth cheese and the second mouse eats the first and the second cheese.As promising and greedy as this approach sounds, it also fails to give us the optimal answer.What is the remedy?Optimal strategyLet’s say we have two types of cheese.` reward1 = [1, 2], reward2 = [60, 50] k = 1`In this example, the first mouse eats 1 cheese. Which cheese should the first mouse eat?If we adhere to our previous approach, the first mosue should eat the first type of cheese, which gives 1 point. And then the second mouse eats the second cheese with a point of 50. In total, we get 51, which is not optimal. The maximim we can achieve is 62. The first mouse eats the second and the second mouse eats the first cheese. What is the strategy then?Let’s look at the point differences between the points of the second mouse and first mouse.60 - 1 = 59 - the first cheese50 - 2 = 48 - the second cheeseThe first mouse eats the second type of cheese which has less difference than the first type of cheese. This difference tells us that the first mouse should eat k types of cheese where the differnece between the poings of the second mouse and the first mouse is small. So the first mouse eats types of cheese with the smallest k differences. The second mouse eats the rest of the cheese. This gives us an optimal strategy.Now let’s see the code.#define vv std::vector#define pp std::pairclass Solution {public:    int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) {        int n = int(reward1.size());        vv&lt;pp&lt;int, pp&lt;int, int&gt;&gt;&gt; diffs(n);        for(int i = 0; i &lt; n; i++)        {            //{difference, reward1[i], reward2[i]}            diffs[i] = {reward2[i] - reward1[i], {reward1[i], reward2[i]}};        }        //sort based on the difference        std::sort(diffs.begin(), diffs.end());        int ans = 0;        //the first mouse eats the first k cheese (according to smallest difference)        for(int i = 0; i &lt; k; i++)        {            ans += diffs[i].second.first;        }        //the second mouse eats the remaing cheese        for(int i = k; i &lt; n; i++)        {            ans += diffs[i].second.second;        }        return ans;    }};I hope you enjoyed your time. Come back for more!"
  },
  
  {
    "title": "LeetCode -678 Valid Parenthesis String",
    "url": "/posts/Valid-Parenthesis-String-678/",
    "categories": "Problem-Solving, LeetCode",
    "tags": "LeetCode, Dynamic programming, Stack, Greedy",
    "date": "2024-04-08 14:58:00 +0400",
    





    
    "snippet": "678 Valid Parenthesis stringGiven a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.The following rules define a valid string:  Any left parenthesis ...",
    "content": "678 Valid Parenthesis stringGiven a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.The following rules define a valid string:  Any left parenthesis '(' must have a corresponding right parenthesis ')'.  Any right parenthesis ')' must have a corresponding left parenthesis '('.  Left parenthesis '(' must go before the corresponding right parenthesis ')'.  '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".Example 1 :Input: s = \"()\"Output: trueExample 2 :Input: s = \"(*)\"Output: trueExample 3 :Input: s = \"(*))\"Output: trueLet’s solve this problem.Simplified problemThe problem would be easy if it asked us to check if the given string consisting of '(' and ')' characters is valid.For example, if we had to check whether or not this string \"()((())())\" is valid, we could do that really easily. In a valid string like this, the number of opening parentheses '(' is equal to the closing parentheses ')'. So in other words, each opening parantheses will be balanced by a corresponding closing parantheses. For example, if we have 5 opening parantheses in a valid string, then we will have 5 closing parantheses.Let’s have a look at \"()((())())\". In this string, we have 5 '(' and 5 ')'. We would start with a counter, which represents the number of '(' encountered so far that has not been balanced by ')'. Each time we come across a '(', we increment the counter. Otherwise, the character is a ')', then we would decrement the counter. If the counter is zero, this means we do not have any opening parantheses that would match the current closing parantheses ')', thus we can stop the process and return false.If we process all of the characters without counter going down to zero, we successfully matched all the closing parantheses with a corresponding opening parantheses. Now we have to check if we actually used all of the opening parantheses, meaning that we have to check if counter is zero. If it is zero, the string is valid, otherwise it is not valid.ApproachIn our problem, we have also '*', which can denote any of \"\", '(', ')'. For example, the string \"(*)\" could be \"()\", \"(()\", \"())\", where '*' is replaced by \"\", '(', ')' respectively.So for each '*', there are 3 possibilities of replacement. We replace it with any of these \"\", '(', ')'. Now let’s say there are k characters of '*'. For each, we have 3 choices, giving us a total of $3^k$ possible strings.One possible solution is to solve this problem with a dynamic programmign approach. Particularly memoization approach.Imagine a function f(counter, index, string) that takes the number of opening parantheses and an index and the string. This function checks if the given string is valid startign from the given index by taking the given counter into account. We can use this function to solve the problem of checking if a given string is valid, where the string does not contain '*'.Given s = \"(())()\", the function call f(0, 0, s) would return true, as the given string is valid.We can also use this function to solve our original problem. If at index, we come across '*', we know that that means three 3 possible choices, meaning replaceing it with \"\", ‘(', or ')'. If we replace it with empty string, the counter does not change, so we call f(counter, index + 1, s). If we replace it with '(', the counter increases by 1 and we call f(counter + 1, index + 1, s). And if we replace it with ')', then counter decreases by 1. And of course, we don’t forget to check if the counter is already zero much as we did in the solution of simplified problem. If it is zero, we return false, otherwise we call f(counter - 1, index + 1, s). If any of these function calls returns true, then we return true.Now let’s see the solution  Note: I have used some shortcuts in the code such as vv.  Note: This problem can be solved in O(n) time and O(1) space with a greedy approach, which can be driven from the dynamic programming solution#define vv std::vectorvv&lt;vv&lt;int&gt;&gt; dp;bool solve(int cnt, int i, std::string &amp;s){    //this means we ran out of opening parantheses in the previous index    if (cnt &lt; 0)         return false;    //check if we reached the end of the string    if (i &gt;= int(s.length()))    {        if (cnt == 0)            return true;        else            return false;    }    //check if we have already calculated the answer for this subproblem    if (dp[cnt][i] != -1)        return dp[cnt][i];    //increment the counter and move on to the next index    if (s[i] == '(')    {        dp[cnt][i] = solve(cnt + 1, i + 1, s);        return dp[cnt][i];    }    else if (s[i] == ')')    {        //counter is zero, we don't have any opening parantheses        if(cnt == 0) return false;        //otherwise, decrement the counter and move to the next index        dp[cnt][i] = solve(cnt - 1, i + 1, s);        return dp[cnt][i];    }    else    { // we encountered '*'. Check 3 possibilites        dp[cnt][i] = solve(cnt, i + 1, s) || solve(cnt + 1, i + 1, s) || solve(cnt - 1, i + 1, s);        return dp[cnt][i];    }}class Solution {public:    Solution()    {        std::ios_base::sync_with_stdio(false); std::cin.tie(NULL);    }    bool checkValidString(string s) {        dp = vv&lt;vv&lt;int&gt;&gt;(100, vv&lt;int&gt;(100, -1));        int cnt = 0;        return solve(cnt, 0, s);    }};I hope you enjoyed your time. Come back for more!  This post is not complete and future refinements are possible."
  },
  
  {
    "title": "LeetCode 421. Maximum XOR of Two Numbers in an Array",
    "url": "/posts/LeetCode-Maximum-XOR-of-Two-Numbers-in-an-Array421/",
    "categories": "Problem-Solving, LeetCode",
    "tags": "LeetCode, Bit Manipulation, Trie",
    "date": "2024-04-07 08:58:00 +0400",
    





    
    "snippet": "421 Maximum XOR of Two Numbers in an ArrayGiven an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.Example 1:Input: nums = [3,10,5,25,2,8] Outpu...",
    "content": "421 Maximum XOR of Two Numbers in an ArrayGiven an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.Example 1:Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28.Example 2:Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127ApproachWhen is the value of a ^ b maximum ? To answer the question let’s see an example.101 and 101. If we take XOR of these two numbers, we get 0. Why ?As all of the bits of two numbers are identical, we get 0 as a result of XOR operation.    1011XOR      0101   ______    1110We get a 0 bit when both bits are the same, meaing 0 XOR 0 and 1 XOR 1 give us 0. When bits differ, we get a 1 bit, meaning 1 XOR 0 and 0 XOR 1 give us 1.So if we want to maximize a XOR b, we want as many oppesite bits as possible. For example, if the current bit of a is 1, then we want the current bit of b to be 0. Ideally we want b to be the complement of a or vise versa.  What is the complement of a number ?We can obtain the complement of an integer in C++ by using the following syntax.int n = 5; //0b101int m = ~i; //0b010We get the complement of a number by inverting each bit (makeing 0 bit 1 and vise versa).For a given number n, if there exist its complement, then taking XOR of n and its complement result in the maximum value for n.Consequently, for each number n in the array, we have to look for a number x that has as many same bits as possible with the complement of n. It is possible that we also find exact complement of n as well. Furthermore, we want the matching bits as far left as possible. Because it is good to have matching bits near to MSB (Most Significant Bit), which is the left most bit.For instance, n is 1001101. Its complement is 0110010. We have to look for the aforementioned number x. If we find that x is 0110010, then it is great. We have found the exact complement of n. We might find something like 0010010. That was not bad. Only one bit (3rd bit from left) is defferent. The rest matches the complement.So here’s our idea. For each number in the array, we will search for a number that is closest to the complement of the current number in terms of matching bits. Then we will take XOR of the current number and the found number and update our answer accordingly.  How are we going to find that number?Essentially, we will work with the binary forms of the numbers. We are working on 32-bit type integers.For doing the actual matching, we will use trie data structure.  Trie is a tree-like data structure most suitable for efficient prefix and suffix searching.In our problem, we will build the trie based on the given numbers in the array. We will use the full 32 bit binary representation of each number. After adding each number to the trie, we will do the actual matter - searching for the closest match for complement of each number.In a usual trie implementation, there is a query operation that search for a given prefix in the trie. When it falls to find a prefix match, it directly returns false to implay that the given prefix does not match any string in the trie.In our case we do not want that as we want to match as many bits as possible while allowing some bits to be different than the complement. While searching the trie, if the current bit in complement does not match the current bit of the trie, we will choose the other bit of the trie and proceed with the rest of the bits of  the complement.Now let’s have a look at the code.Before looking at the code, please acquaint yourself with the following bit manipulation techniques.      x &lt;&lt; k left bit shift operator. It shifts bits of x k bit to the left.     x &gt;&gt; k right bit shift operator. It shifts bits of x k bit to the right     x &amp; y AND operator gives a number that has one bits in positions where x and y have set bits (one bits)     x | y OR operator gives a number that has one bits in positions where at leasat one of x and y has a one bit.     x ^ y XOR operator gives a number that has one bits in postions where x and y have different bits.     ~x NOT operator gives a number where all bits of x have been flipped (0 turns into 1 and vise versa)    1 &lt;&lt; k bit mask of this form has a one bit in position k (0-indexed). The rest of the bits are zero. We use this bit mask to access a single bit of a number. You can combine this bit mask for different bit manipulation purposes, such as setting a bit to one or zero, flipping a particular bit.    Last but not least, a postive integer x is a power of two if x &amp; (x - 1) == 0.  //Build the trie on the given array//Then search the complement of each number in the trie//There might not be the exact complement of the given number //We will match as much as possible//then we take the XOR of the curren number and what we found in trie.struct Trie{    Trie* nodes[2];    Trie() {        nodes[0] = NULL;        nodes[1] = NULL;    }};void insert(Trie*&amp; t, int n){    Trie* curr = t;    for(int i = 31; i &gt;= 0; i--)    {        int bit = (n&amp;(1&lt;&lt;i)) == 0 ? 0 : 1; //ith bit        if(curr-&gt;nodes[bit] == NULL)            curr-&gt;nodes[bit] = new Trie();        curr = curr-&gt;nodes[bit];    }}int find(Trie*&amp; t, int n){    Trie* curr = t;    int res = n;    for(int i = 31; i &gt;= 0; i--)    {        int bit = (n&amp;(1&lt;&lt;i)) == 0 ? 0 : 1;        if(curr-&gt;nodes[bit] == NULL)        {            res = res ^ (1&lt;&lt;i);            curr = curr-&gt;nodes[bit ^ 1];        } else         {            curr = curr-&gt;nodes[bit];        }    }    return res;}void bin(int n ){    for(int i = 31; i &gt;= 0; i--)    {       int x = (n&amp;(1&lt;&lt;i)) == 0 ? 0 : 1;       std::cout &lt;&lt; x ;    }}class Solution {public:    Solution()    {        std::ios_base::sync_with_stdio(false); std::cin.tie(NULL);    }    int findMaximumXOR(vector&lt;int&gt;&amp; a) {        Trie* t = new Trie();        int ans = 0;        for(int i : a)        {            insert(t, i);        }        for(int i : a)        {            int x = find(t, ~i);            ans = std::max(ans, (x ^ i));        }        return ans;    }};I hope you enjoyed your time. Come back for more!."
  }
  
]

